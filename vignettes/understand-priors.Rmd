---
title: "Understand and explore priors"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Understand and explore priors}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, message=FALSE, warning=FALSE}
library(tidyverse)
theme_set(theme_minimal())
library(learnB4SS)
library(HDInterval)
library(extraDistr)
library(brms)
data(emotion)
data(vowels)
```

# Overview

This vignette digs a bit deeper into priors for different types of outcome/response variables.
We will cover outcome variables that follow these distributions: normal/Gaussian, log-normal, binomial/Bernoulli, poisson, and beta.


# Normal/Gaussian

Let's start off with an outcome variable distributed according to a normal/Gaussian distribution.

In fact, we hardly ever work with truly normally distributed variables.
So for this example we will look at a data set of lexical emotional valence.

```{r emotion}
emotion
```

The `emotion` tibble contains a list of 1000 English words (`word`) and their emotional valence (`valence`).
Emotional valence is given as a number between `-4` and `+4`, which correspond to "bad valence" and "good valence" respectively.

The variable `valence` is in principle distributed according to a normal/Gaussian distribution (simply "normal" from now on).
NOTE that the probability distribution of the outcome variable (aka likelihood, family) should not be chosen based on visual inspection, but based on conceptual principles.

Another word of warning is that plotting continuous outcome variables with `geom_density()` does not allow us to assess which distribution the variable follows, because the data might have been generated by a mixture of distributions.

A quick plot of the outcome variable should just be used to ensure that the data is ok (i.e. doesn't contain errors).

```{r valence-density}
emotion %>%
  ggplot(aes(valence)) +
  geom_density() +
  geom_rug(alpha = 0.5)
```

All seems good.

Now, what we want to do is simply to model the distribution of `valence`.

`valence` follows a normal distribution:

$$valence_i \sim Normal(\mu, \sigma)$$

So in fact we want to estimate $\mu$ and $\sigma$ from the data.

We need to set a prior probability distribution (or simply prior) for $\mu$ and one prior for $\sigma$.

A go-to prior distribution for $\mu$ is yet another normal distribution, with its own $\mu_1$ and $\sigma_1$.

$$\mu \sim Normal(\mu_1, \sigma_1)$$

As a general rule, we recommend using so-called **regularising priors** by setting $\mu_1$ to `0`.

$$\mu \sim Normal(0, \sigma_1)$$

To decide what value to assign to $\sigma_1$, we can use the **empirical rule**: the 95% CrI of a normal distribution is the interval contained within the range defined by $\mu \pm 2\sigma$.

Since `valence` ranges between `-4` and `+4` by definition, a conservative approach for $\mu$ is to allow for values between `-8` and `+8`.

Since $\mu_1 = 0$, then $\sigma_1$ is $8/2 = 4$.

$$\mu \sim Normal(0, 4)$$

This is how $Normal(0, 4)$ looks like.

```{r mu-prior}
x <- seq(-15, 15, by = 0.01)
y <- dnorm(x, 0, 4)

ggplot() +
  aes(x, y) +
  geom_line()
```

So now we know which prior we will set for $\mu$.

For $\sigma$, one can choose from a normal distribution, a Student-t distribution, or a Half-Cauchy distribution.

We will go with the latter.

$$\sigma \sim HalfCauchy(x, \gamma)$$

With Half-Cauchy distributions you can safely set $x = 0$.

$$\sigma \sim HalfCauchy(0, \gamma)$$

We cannot use the empirical rule to decide what value $\gamma$ should have, because the rule works only with normal distributions.

Instead, we can use the `inverseCDF()` function from the HDInterval package (see the function documentation for a full explanation).

We don't really have an idea of what the standard deviation for the `valence` scores might be, and we cannot calculate the standard deviation from the data (that would be cheating!).

So we just go with a quite weakly informative prior.

```{r hcauchy}
# phcauchy is from the extraDistr package
# If you are wondering why 0.025 and 0.975, that is the range that gives you
# a 95% CrI/HDI.
# Note that the phcauchy function calls gamma "sigma" but it means the same here.
inverseCDF(c(0.025, 0.975), phcauchy, sigma = 1)
```

The functions returns the lower and upper boundary of the 95% HDI (Highest Density Interval).
The range `[0, 25]` for the standard deviation encompasses a very large range of values, given the range of `valence` (`[-4, +4]`), making the prior a weakly informative one.

The prior for $\sigma$ then is:

$$\sigma \sim HalfCauchy(0, 1)$$

To sum up:

$$
\begin{aligned}
valence_i & \sim Normal(\mu, \sigma)\\
\mu & \sim Normal(0, 4)\\
\sigma & \sim HalfCauchy(0, 1)
\end{aligned}
$$

The corresponding code for $valence_i \sim Normal(\mu, \sigma)$ is:

```{r m1-formula, eval=FALSE}
m1 <- brm(
  valence ~ 1,
  data = emotion,
  family = gaussian()
)
```

We can check which priors we should specify:

```{r m1-get-prior}
get_prior(
  valence ~ 1,
  data = emotion,
  family = gaussian()
)
```

The brms code for setting the priors is:

```{r priors-1}
priors_1 <- c(
  # class Intercept = mu
  prior(norma(0, 4), class = Intercept),
  # no need to specify that cauchy should be half
  # that is done automatically by brms
  prior(cauchy(0, 1), class = sigma)
)
```

At this point you would normally do prior predictive checks.
We will show you how in the next example.

After you made sure the prior predictive checks are fine, you would go on to run the model with your priors (not run here).

```{r m1, eval=FALSE}
m1 <- brm(
  valence ~ 1,
  data = emotion,
  family = gaussian(),
  prior = priors_1
)
```

# Log-normal

Several measures that can only take on positive values, like segment duration, tend to have a skewed probability distribution.
One such type of distribution is the **log-normal** distribution.

To illustrate how to run a Bayesian regression model with log-normal data, we will use a data set of vowel duration.
Segment durations are known to follow a log-normal distribution, since durations can only be positive.
This characteristics produces the typical right skew of log-normal data.

Let's have a look at the data.

```{r vowels}
glimpse(vowels)
```

And let's plot the raw vowel duration.

```{r vow-duration}
vowels %>%
  ggplot(aes(v1_duration)) +
  geom_density() +
  geom_rug()
```

We can start off with this simple formula:

$$vow\_dur_i \sim Lognormal(\mu_i, \sigma)$$

Vowel duration is distributed according to a log-normal distribution, which has a mean $\mu$ and a standard deviation $\sigma$.
We want to estimate $\mu$ and $\sigma$ from the data.

This time though, we also have a few predictors we are interested in: C2 voicing (voiceless, voiced), C2 place of articulation (coronal, velar), vowel (/a/, /o/, /u/), and speech rate (syllables per second).

The predictors of a linear model are assumed to have an effect on $\mu$.
The following formula for $\mu$ from above should make this evident:

$$
\begin{aligned}
\mu_i & = \alpha + \beta_1 \times c2voicing_i + \beta_2 \times c2poa_i \\
& + \beta_3 \times vowelO_i + \beta_4 \times vowelU_i \\
& + \beta_5 \times srate_i
\end{aligned}
$$

$\alpha$ is the parameter of the model intercept, while the $\beta$ parameters are the coefficients of the predictors.

For each of these parameters we need to set a prior.

To be continued...

<br>
